Java Syntax Specification
Programs
<compilation unit> ::= <type declarations>

Declarations
<type declarations> ::= <type declaration> | <type declarations> <type declaration>
<type declaration> ::= <class declaration> | ;
<class declaration> ::=class <identifier>? <class body>
<class body> ::= { <class body declarations>? }
<class body declarations> ::= <class member declaration> | <class body declarations> <class member declaration> 
<class member declaration> ::= <field declaration> | <method declaration>
<formal parameter list> ::= <formal parameter> | <formal parameter list> , <formal parameter>
<formal parameter> ::= <type> <variable declarator id>
<class type list> ::= <class type> | <class type list> , <class type>
<field declaration> ::= <type> <variable declarators> ;
<variable declarators> ::= <variable declarator> | <variable declarators> , <variable declarator>
<variable declarator> ::= <variable declarator id> | <variable declarator id> = <variable initializer>
<variable declarator id> ::= <identifier> | <variable declarator id> [ ]
<variable initializer> ::= <expression> | <array initializer>
<method declaration> ::= <method header> <method body>
<method header> ::= <result type> <method declarator> 
<result type> ::= <type> 
<method declarator> ::= <identifier> ( <formal parameter list>? )
<method body> ::= <block> | ;
<array initializer> ::= { <variable initializers>? , ? }
<variable initializers> ::= <variable initializer> | <variable initializers> , <variable initializer>
<variable initializer> ::= <expression> | <array initializer>
Types
<type> ::= <primitive type> | <reference type>
<primitive type> ::= <numeric type> | boolean
<numeric type> ::= <integral type> | <floating-point type>
<integral type> ::= char
<floating-point type> ::= double
<reference type> ::= <array type>
<array type> ::= <type> [ ]
Blocks and Commands
<block> ::= { <block statements>? }
<block statements> ::= <block statement> | <block statements> <block statement>
<block statement> ::= <local variable declaration statement> | <statement>
<local variable declaration statement> ::= <local variable declaration> ;
<local variable declaration> ::= <type> <variable declarators>
<statement> ::= <statement without trailing substatement> | <if then statement> | <if then else statement> | <while statement>
<statement no short if> ::= <statement without trailing substatement> | <if then else statement no short if> | <while statement no short if> | <for statement no short if>
<statement without trailing substatement> ::= <block> | <empty statement> | <expression statement> | <break statement> | <continue statement> | <return statement> 
<empty statement> ::= ;
<expression statement> ::= <statement expression> ;
<statement expression> ::= <assignment> | <method invocation> 
<if then statement>::= if ( <expression> ) <statement>
<if then else statement>::= if ( <expression> ) <statement no short if> else <statement>
<if then else statement no short if> ::= if ( <expression> ) <statement no short if> else <statement no short if>
<while statement> ::= while ( <expression> ) <statement>
<while statement no short if> ::= while ( <expression> ) <statement no short if>
<statement expression list> ::= <statement expression> | <statement expression list> , <statement expression>
<break statement> ::= break <identifier>? ;
<continue statement> ::= continue <identifier>? ;
<return statement> ::= return <expression>? ;
Expressions
<constant expression> ::= <expression>
<expression> ::= <assignment expression>
<assignment expression> ::= <conditional expression> | <assignment>
<assignment> ::= <left hand side> <assignment operator> <assignment expression>
<left hand side> ::= <expression name> | <field access> | <array access>
<assignment operator> ::= = 
<conditional expression> ::= <conditional or expression> | <conditional or expression> ? <expression> 
<conditional or expression> ::= <conditional and expression> | <conditional or expression> || <conditional and expression>
<conditional and expression> ::= <inclusive or expression> | <conditional and expression> && <inclusive or expression>
<inclusive or expression> ::= <exclusive or expression> | <inclusive or expression> | <exclusive or expression>
<exclusive or expression> ::= <and expression> | <exclusive or expression> ^ <and expression>
<and expression> ::= <equality expression> | <and expression> & <equality expression>
<equality expression> ::= <relational expression> | <equality expression> == <relational expression> | <equality expression> != <relational expression>
<relational expression> ::= <shift expression> | <relational expression> < <shift expression> | <relational expression> > <shift expression> | <relational expression> <= <shift expression> | <relational expression> >= <shift expression> | <relational expression> instanceof <reference type>
<additive expression> ::= <multiplicative expression> | <additive expression> + <multiplicative expression> | <additive expression> - <multiplicative expression>
<multiplicative expression> ::= <unary expression> | <multiplicative expression> * <unary expression> | <multiplicative expression> / <unary expression> | <multiplicative expression> % <unary expression>
<unary expression> ::= + <unary expression> | - <unary expression> | <unary expression not plus minus>
<unary expression not plus minus> ::= ~ <unary expression> | ! <unary expression> | <cast expression>
<postfix expression> ::= <primary> | <expression name> 
<method invocation> ::= <method name> ( <argument list>? ) 
<primary> ::= <primary no new array> | <array creation expression>
<primary no new array> ::= <literal> | ( <expression> ) | <method invocation> | <array access>
<argument list> ::= <expression> | <argument list> , <expression>
<array creation expression> ::= new <primitive type> <dim exprs> <dims>? 
<dim exprs> ::= <dim expr> | <dim exprs> <dim expr>
<dim expr> ::= [ <expression> ]
<dims> ::= [ ] | <dims> [ ]
<array access> ::= <expression name> [ <expression> ] | <primary no new array> [ <expression>]
Tokens
<type name> ::= <identifier> 
<simple type name> ::= <identifier>
<expression name> ::= <identifier> 
<method name> ::= <identifier> 
<literal> ::= <integer literal> | <floating-point literal> | <boolean literal> | <character literal> | <string literal> 
<integer literal> ::= <decimal integer literal>
<decimal integer literal> ::= <decimal numeral> <integer type suffix>?
<decimal numeral> ::= 0 | <non zero digit> <digits>?
<digits> ::= <digit> | <digits> <digit>
<digit> ::= 0 | <non zero digit>
<non zero digit> ::= 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
<hex digit> :: = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | a | b | c | d | e | f | A | B | C | D | E | F
<floating-point literal> ::= <digits> . <digits>? 
<digits> 
<sign> ::= + | -
<boolean literal> ::= true | false
<character literal> ::= ' <single character> ' | ' <escape sequence> '
<single character> ::= <input character> except ' and \
<string literal> ::= " <string characters>?"
<string characters> ::= <string character> | <string characters> <string character>
<string character> ::= <input character> except " and \ | <escape character>
<keyword> ::= boolean | break | char | class | continue | double | else | if | new | return | while

The character set for Java is Unicode, a 16-bit character set. This is the set denoted by <input character>. Unicode effectively contains the familiar 7-bit ASCII characters as a subset, and includes "escape code" designations of the form \udddd (where each d is from <hex digit>). In the extended BNF for Java the optional appearance of X is written X?, and the iterative appearance of X is written {X}.
The syntax category <identifier> consists of strings that must start with a letter - including underscore (_) and dollar sign ($) - followed by any number of letters and digits. Characters of numerous international languages are recognized as "letters" in Java. A Java letter is a character for which the method Character.isJavaLetter returns true. A Java letter-or-digit is a character for which the method Character.isJaveLetterOrDigit returns true. Also, <identifier> includes none of the keywords given above - these are reserved words in Java.
The only BNF extention used here is the optional construct which is written with '?' added as a suffix to a terminal or non-terminal. Note that '*', '{', and '}' are all terminal symbols. This BNF definition does not address such pragmatic issues as comment conventions and the use of "white space" to delimit tokens. This BNF also does not express numerous "context-sensitive" restrictions on syntax. For instance, type use of identifiers must be consistent with the required declarations, there are size limitations on numerical literals, etc.